# -*- coding: utf-8 -*-
"""MUST_TASK

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IbTYDUEx8yvOCIrRtCnjYvxoAKTDf1K8
"""

import numpy as np 
import pandas as pd 
import os
from keras.preprocessing.image import ImageDataGenerator
from keras.applications import VGG16
from keras import applications
from keras.layers import Conv2D, MaxPooling2D, BatchNormalization, GlobalAveragePooling2D
from keras.layers import Activation, Dropout, Flatten, Dense
from keras.optimizers import RMSprop, SGD
from keras.models import Model, Sequential
import matplotlib.pyplot as plt
from keras.layers import Input
from keras import models
from keras import layers
from keras import optimizers
from keras.preprocessing import image

TrainPath="/content/drive/My Drive/data/train"
ValPath="/content/drive/My Drive/data/val"

TrainGen = ImageDataGenerator(
    rescale=1. / 255,
    rotation_range=10,  
    zoom_range = 0.1, 
    width_shift_range=0.1,  
    height_shift_range=0.1,  
    vertical_flip=False,
    horizontal_flip=True)


ValGen = ImageDataGenerator(rescale=1. / 255)

train_generator = TrainGen.flow_from_directory(
    TrainPath,
    target_size=(224, 224),
    batch_size=16,
    class_mode='categorical')

validation_generator = ValGen.flow_from_directory(
    ValPath,
    target_size=(224, 224),
    batch_size=16,
    class_mode='categorical')

input_tensor = Input(shape=(224, 224, 3))
vgg_conv = VGG16(weights='imagenet',
                               include_top=False,
                               input_tensor=input_tensor)
# Freeze the layers except the last 4 layers
for layer in vgg_conv.layers[:-4]:
    layer.trainable = False
 
# Check the trainable status of the individual layers
for layer in vgg_conv.layers:
    print(layer, layer.trainable)

# Create the model
model = models.Sequential()
 
# Add the vgg convolutional base model
model.add(vgg_conv)
 
# Add new layers
model.add(layers.Flatten())
model.add(layers.Dense(5000, activation='relu'))
model.add(layers.Dropout(0.5))
model.add(layers.Dense(5, activation='softmax'))
 
# Show a summary of the model. Check the number of trainable parameters
model.summary()



model.compile(loss='categorical_crossentropy',
              optimizer=optimizers.RMSprop(lr=1e-5),
              metrics=['acc'])

history = model.fit_generator(
    train_generator,
    steps_per_epoch=93// 16,
    epochs=50,
    validation_data=validation_generator,
    validation_steps=25 // 16)

# summarize history for accuracy
plt.plot(history.history['acc'])
plt.plot(history.history['val_acc'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()
# summarize history for loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

model.save_weights('MUST_TASK.h5')

import cv2
labels = ['ben_afflek',  'elton_john',  'jerry_seinfeld',  'madonna',  'mindy_kaling']
img = image.load_img('/content/httpcdnfuncheapcomwpcontentuploadsVOGUEjpg.jpg', target_size=(224, 224))
x = image.img_to_array(img)
x = np.expand_dims(x, axis=0)
x /= 255.
prediction = model.predict(x)[0]
print(prediction)

m=max(prediction)
res=[s for s, h in enumerate(prediction) if h == m]
print(res)

img = cv2.imread('/content/httpcdnfuncheapcomwpcontentuploadsVOGUEjpg.jpg', cv2.IMREAD_COLOR)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.axis('off')
plt.title("{}, {:.2f}%".format(labels[res[0]], prediction[res[0]]*100))
plt.imshow(img)